package flosc;//import java.awt.event.*;import java.util.*;//import java.awt.*;import java.io.*;import java.net.*;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.ParserConfigurationException;import org.w3c.dom.Document;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import org.xml.sax.InputSource;import org.xml.sax.SAXException;/** * TcpServer <BR><BR> Flash XML Socket Server for Gateway. Based on CommServer by Derek Clayton. * @author    Ben Chun        ben@benchun.net * @author	  Ignacio Delgado   idelgado@h-umus.it * @version   2.0 */public class TcpServer extends Thread {    private Vector<TcpClient> clients = new Vector<TcpClient>();  	// all connected Flash clients    private int port;                       						// the TCP port    ServerSocket server;                    						// the TCP server    Gateway gateway;                        						// Gateway for this server        /**     * Constructor for the TcpServer.     * @param   port   TCP port for Flash client connections.     * @param   gateway  parent Gateway.    */    public TcpServer(int port, Gateway gateway)     {		this.port = port;		this.gateway = gateway;        System.out.println("TcpServer created...");    }    /**     * Thread run method.  Monitors incoming messages.    */	    public void run()     {        try {            // --- create a new TCP server            server = new ServerSocket(port);            Debug.writeActivity("TCP XML/Flash server started on port: " + port,this);            // --- while the server is active...            while(true)             {                // --- ...listen for new client connections                Socket socket = server.accept();                TcpClient client = new TcpClient(this, socket);                Debug.writeActivity(client.getIP()+ " connected to TCP XML/Flash server.",this);                // --- add the new client to our client list                 clients.addElement(client);                // --- start the client thread                client.start();            }        }         catch(IOException ioe)         {            Debug.writeActivity("Server error...Stopping TCP XML/Flash server",this);            // kill this server            killServer();        }     }    /**     * Broadcasts a message to all connected Flash clients.     * Messages are terminated with a null character.     *     * @param   message    The message to broadcast.    */    public synchronized void broadcastMessage(String message) {        // --- add the null character to the message        message += '\0';                // --- enumerate through the clients and send each the message        for ( TcpClient client : clients)        	client.send(message);    }    /**     * Takes incoming XML-encoded OSC and creates an OSC packet for     * the Gateway to send.  This pseduo-parser method does not     * validate the XML in any way, so client applications should take     * care to send only well-formed XMl that would validate against     * flosc.dtd (usually this is not a problem, since flosc.fla does     * it correctly).     *     * @param   client    The TcpClient to remove.     *     */    public void handleOsc(String oscxml) throws UnknownHostException {    	// DEBUG    	Debug.writeActivity(oscxml,this);    	//  parse the XML, create an OscPacket		Debug.writeActivity("Received TCP packet, parsing XML...",this);				DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();		DocumentBuilder builder;				try 		{			builder = factory.newDocumentBuilder();			Document document = builder.parse(new InputSource(new StringReader(oscxml)));						Node oscNode = null;			if(document.getElementsByTagName("OSCPACKET").getLength()<1)			{							Debug.writeActivity("Parse error: data outside OSCPACKET element",this);				return;			}			else			{				OscPacket packet = new OscPacket();								oscNode=document.getElementsByTagName("OSCPACKET").item(0);				packet.setTime( Long.parseLong(oscNode.getAttributes().getNamedItem("TIME").getNodeValue()) );				packet.setAddress( InetAddress.getByName(oscNode.getAttributes().getNamedItem("ADDRESS").getNodeValue()) );				packet.setPort( Integer.parseInt(oscNode.getAttributes().getNamedItem("PORT").getNodeValue()) );								NodeList oscMessages = document.getElementsByTagName("MESSAGE");				if(oscMessages.getLength()<1)					return;				for(int i = 0; i < oscMessages.getLength(); i++)				{					Node xmlMessage = oscMessages.item(i);					OscMessage message = new OscMessage ( xmlMessage.getAttributes().getNamedItem("NAME").getNodeValue());										NodeList oscArguments = xmlMessage.getChildNodes();					for( int j=0;j< oscArguments.getLength();j++)					{						Node argument = oscArguments.item(j);						if(argument.getNodeName().equals("ARGUMENT"))						{							char argType = argument.getAttributes().getNamedItem("TYPE").getNodeValue().charAt(0);							String argValue = argument.getAttributes().getNamedItem("VALUE").getNodeValue();							Character type = new Character(argType);							switch(argType)							{								case 'i': case 'r': case 'm': case 'c':								    Integer in = Integer.valueOf( argValue );								    message.addArg(type, in);								    break;								case 'f':								    Float f = Float.valueOf( argValue );								    message.addArg(type, f);								    break;								case 'h': case 't':								    Long l = Long.valueOf( argValue );								    message.addArg(type, l);								    break;								case 'd':								    Double d = Double.valueOf( argValue );								    message.addArg(type, d);								    break;								case 's': case 'S':								    message.addArg(type, unescape(argValue));								    break;							}						}					}					packet.addMessage(message);				}				//				gateway.sendPacket(packet);			}					} catch (ParserConfigurationException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (SAXException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (IOException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}    }    /**     * Replaces escape codes in a string with the literal     * characters. (e.g.: "%20" is replaced with a space).     *     * (c) 2001 by Phil Scovis, all rights reserved.  This code is     * provided as-is, without warranty.  You may copy, use, or     * distribute this code, provided that you add value to it and     * include this notice.     *     * @param s the string with escape codes.     * @return the string with the escape codes replaced.     */    public String unescape(String s)    {		String retval="";		try 		{			retval = URLDecoder.decode(s, "UTF-8");		} 		catch (UnsupportedEncodingException e) 		{			// TODO Auto-generated catch block			e.printStackTrace();		}		return retval;    }            /**     * Removes clients from the client list.     *     * @param   client    The TcpClient to remove.     *    */    public void removeClient(TcpClient client)     {        Debug.writeActivity(client.getIP() + " has disconnected from the server.",this);                // --- remove the client from the list        clients.removeElement(client);            }    /**     * Stops the TCP server.    */    public void killServer()     {        try         {            // --- stop the server            server.close();            Debug.writeActivity("TCP XML/Flash server stopped",this);        }         catch (IOException ioe)         {            Debug.writeActivity("Error while stopping TCP XML/Flash server",this);        }    }}