/* 	This file is part of Throng - Tuio multiplexeR that crOps and Globalizes.	For more information see http://code.google.com/p/throng		Copyright (c) 2010-2011 Johannes Luderschmidt <ich@johannesluderschidt.de>    Throng is free software: you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation, either version 3 of the License, or    (at your option) any later version.    Throng is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License    along with Throng. If not, see <http://www.gnu.org/licenses/>. */package de.johannesluderschmidt.throng.proxy;import java.net.InetAddress;import java.net.SocketException;import java.net.UnknownHostException;import java.util.ArrayList;import java.util.Date;import java.util.Hashtable;import java.util.Vector;import com.illposed.osc.OSCBundle;import com.illposed.osc.OSCListener;import com.illposed.osc.OSCMessage;import com.illposed.osc.OSCPacket;import com.illposed.osc.OSCPortIn;import com.illposed.osc.OSCPortOut;import de.johannesluderschmidt.simpleDebug.Debug;import de.johannesluderschmidt.throng.util.Constants;/** * @author	  Johannes Luderschmidt 	ich@johannesluderschmidt.de */public class ThrongProxy implements OSCListener{	private static ThrongProxy inst;	    private Vector<OSCPortIn> oscPortsIn;    private ArrayList<OSCListener> listeners;    private Hashtable<String,SourceIpPortBean> connectedSources;    private OSCPortOut oscPortOut;	    private ThrongProxy(){    	listeners = new ArrayList<OSCListener>();    	connectedSources = new Hashtable<String, SourceIpPortBean>();    	try {			setOutboundConnection(InetAddress.getByName(Constants.DEFAULT_IP), Constants.DEFAULT_OUTPUT_PORT);		} catch (UnknownHostException e) {			Debug.writeException("Could not initialize proxy because I could not resolve the localhost address", this, e);		}    }    public static ThrongProxy getInstance(){    	if(inst == null){    		inst = new ThrongProxy();    	}    	return inst;    }    public void resetTuioClientMessages(){    	Debug.writeActivity("Sending empty Tuio bundles", this);    	    	for(String key:connectedSources.keySet()){    		SourceIpPortBean bean = connectedSources.get(key);    		if(bean.getSource() != null){    			sendEmptyBundlesWithSource(bean);    		}    	}    	sendEmptyBundlesWithoutSource();    }    private void sendEmptyBundlesWithSource(SourceIpPortBean bean){    	Object[] aliveArguments = {"alive"};    	Object[] fseqArguments = {"fseq",new Integer(ThrongMultiplexer.getInstance().getIncrementedFseq())};		    	OSCPacket[] terminating2DcurBundleArguments;    	OSCPacket[] terminating2DobjBundleArguments;    			Object[] sourceArguments;		sourceArguments = new Object[2];    			sourceArguments[0] = "source";		sourceArguments[1] = bean.getSource();		terminating2DcurBundleArguments = new OSCPacket[3];		terminating2DobjBundleArguments = new OSCPacket[3];    			terminating2DcurBundleArguments[0] = new OSCMessage("/tuio/2Dcur",sourceArguments);		terminating2DcurBundleArguments[1] = new OSCMessage("/tuio/2Dcur",aliveArguments);    	terminating2DcurBundleArguments[2] = new OSCMessage("/tuio/2Dcur",fseqArguments);    	    	terminating2DobjBundleArguments[0] = new OSCMessage("/tuio/2Dobj",sourceArguments);    	terminating2DobjBundleArguments[1] = new OSCMessage("/tuio/2Dobj",aliveArguments);    	terminating2DobjBundleArguments[2] = new OSCMessage("/tuio/2Dobj",fseqArguments);				    	    	OSCBundle terminating2DcurBundle = new OSCBundle(terminating2DcurBundleArguments);    	OSCBundle terminating2DobjBundle = new OSCBundle(terminating2DobjBundleArguments);    			terminating2DcurBundle.setIpAddress(bean.getIpAddress());    	terminating2DcurBundle.setPortOut(bean.getPort());    	    	terminating2DobjBundle.setIpAddress(bean.getIpAddress());    	terminating2DobjBundle.setPortOut(bean.getPort());    	    	try{	    	acceptBundle(new Date(), terminating2DcurBundle);	    	acceptBundle(new Date(), terminating2DobjBundle);    	}catch(Exception e){    		Debug.writeException("Could not multiplex and send terminating bundles", this, e);    	}    }    private void sendEmptyBundlesWithoutSource(){    	Object[] aliveArguments = {"alive"};    	Object[] fseqArguments = {"fseq",new Integer(ThrongMultiplexer.getInstance().getIncrementedFseq())};		    	OSCPacket[] terminating2DcurBundleArguments;    	OSCPacket[] terminating2DobjBundleArguments;    	    	terminating2DcurBundleArguments = new OSCPacket[2];    	terminating2DobjBundleArguments = new OSCPacket[2];    	    	terminating2DcurBundleArguments[0] = new OSCMessage("/tuio/2Dcur",aliveArguments);    	terminating2DcurBundleArguments[1] = new OSCMessage("/tuio/2Dcur",fseqArguments);    	    	terminating2DobjBundleArguments[0] = new OSCMessage("/tuio/2Dobj",aliveArguments);    	terminating2DobjBundleArguments[1] = new OSCMessage("/tuio/2Dobj",fseqArguments);    	    	OSCBundle terminating2DcurBundle = new OSCBundle(terminating2DcurBundleArguments);    	OSCBundle terminating2DobjBundle = new OSCBundle(terminating2DobjBundleArguments);    	    	try{    		oscPortOut.send(terminating2DcurBundle);    		oscPortOut.send(terminating2DobjBundle);    	}catch(Exception e){    		Debug.writeException("Could not send empty termination bundles", this, e);    	}    }    public void startProxy(){    	Debug.writeActivity("Starting gateway.",this);    	for (OSCPortIn oscPortIn : oscPortsIn){    		oscPortIn.startListening();    	}    	resetTuioClientMessages();    }        public void stopProxy(){    	Debug.writeActivity("Stopping gateway.",this);    	if(oscPortsIn != null){	    	for (OSCPortIn oscPortIn : oscPortsIn){	    		oscPortIn.stopListening();	    	}    	}	    resetTuioClientMessages();    }    	public void setInboundPorts(int[] inboundPorts){		oscPortsIn = new Vector<OSCPortIn>(); 		try {			for(int i=0; i < inboundPorts.length; i++){				OSCPortIn portIn = new OSCPortIn(inboundPorts[i]);				portIn.addListener("", this);				oscPortsIn.add(portIn);			}		 } catch (SocketException e) {			Debug.writeException("Socket problems. Could not connect to inbound ports: ", this, e);		 }	}	public int[] getInboundPorts(){		int[] portsIn = new int[oscPortsIn.size()];				int i = 0;		for(OSCPortIn portIn:oscPortsIn){			portsIn[i] = portIn.getPort(); 			i = i+1;		}		return portsIn;	}	public void setOutboundConnection(InetAddress outboundIp, int outboundPort){		try{			this.oscPortOut = new OSCPortOut(outboundIp, outboundPort);		}catch (SocketException e) {			Debug.writeActivity(e.getMessage(),this);		}	}		public void acceptMessage(Date time, OSCMessage message) {}	public void acceptBundle(Date time, OSCBundle bundle){		try {			for(OSCListener listener:listeners){				listener.acceptBundle(time, bundle);			}			Debug.writeActivity("Bundle before multiplexing: "+bundle, this);			bundle = ThrongMultiplexer.getInstance().multiplexTuioBundle(bundle);			bundle = ThrongCropper.getInstance().globalizeTuioBundle(bundle, bundle.getPortIn());			Debug.writeActivity("Bundle after multiplexing: "+bundle, this);						checkSource(bundle);			    		oscPortOut.send(bundle);		} catch (Exception e) {			Debug.writeException("Exception while treating or sending OSCBundle: ",this, e);		}	}	public void checkSource(OSCBundle bundle){		String source = null;		for(OSCPacket packt:bundle.getPackets()){			OSCMessage message = (OSCMessage)packt;			if(message.getArguments()[0] == "source"){				source = (String)message.getArguments()[1]; 			}		}					addConnectedSource(source, bundle.getIpAddress(), bundle.getPortOut());	}		public void addConnectedSource(String source, InetAddress ipAddress, int port){		connectedSources.put(generateConnectedSourceKey(ipAddress, port), new SourceIpPortBean(ipAddress, port, source));	}		public void resetConnectedSources(){		connectedSources.clear();	}		public void addListener(OSCListener listener) {		listeners.add(listener);	}	public void removeListener(OSCListener listener) {		listeners.remove(listener);	}		private String generateConnectedSourceKey(InetAddress ipAddress, int port){		return ipAddress.toString()+":"+port;	}}