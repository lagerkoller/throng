/* 	This file is part of Throng - Tuio multiplexeR that crOps and Globalizes.	For more information see http://code.google.com/p/throng		Copyright (c) 2010-2011 Johannes Luderschmidt <ich@johannesluderschidt.de>    Throng is free software: you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation, either version 3 of the License, or    (at your option) any later version.    Throng is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License    along with Throng. If not, see <http://www.gnu.org/licenses/>. */package de.johannesluderschmidt.throng.proxy;import java.net.InetAddress;import java.net.SocketException;import java.net.UnknownHostException;import java.util.ArrayList;import java.util.Date;import java.util.Hashtable;import java.util.Vector;import com.illposed.osc.OSCBundle;import com.illposed.osc.OSCListener;import com.illposed.osc.OSCMessage;import com.illposed.osc.OSCPacket;import com.illposed.osc.OSCPortIn;import com.illposed.osc.OSCPortOut;import de.johannesluderschmidt.simpleDebug.Debug;import de.johannesluderschmidt.throng.util.Constants;/** * @author	  Johannes Luderschmidt 	ich@johannesluderschmidt.de */public class ThrongProxy implements OSCListener{	private static ThrongProxy inst;	    private Vector<OSCPortIn> oscPortsIn;    private ArrayList<OSCListener> listeners;    private ArrayList<IThrongProxyTerminator> terminators;    private Hashtable<String,SourceIpPortBean> connectedSources;    private OSCPortOut oscPortOut;	    private ThrongProxy(){    	listeners = new ArrayList<OSCListener>();    	connectedSources = new Hashtable<String, SourceIpPortBean>();    	terminators = new ArrayList<IThrongProxyTerminator>();    	try {			setOutboundConnection(InetAddress.getByName(Constants.DEFAULT_IP), Constants.DEFAULT_OUTPUT_PORT);		} catch (UnknownHostException e) {			Debug.writeException("Could not initialize proxy because I could not resolve the localhost address", this, e);		}    }    public static ThrongProxy getInstance(){    	if(inst == null){    		inst = new ThrongProxy();    	}    	return inst;    }    public void resetTuioClientMessages(){    	Debug.writeActivity("Sending empty Tuio bundles", this);    	    	for(String key:connectedSources.keySet()){    		SourceIpPortBean bean = connectedSources.get(key);    		if(bean.getSource() != null){    			for(IThrongProxyTerminator terminator:terminators){    				terminator.sendEmptyBundlesWithSource(bean);    			}    		}    	}    	for(IThrongProxyTerminator terminator:terminators){			terminator.sendEmptyBundlesWithoutSource(oscPortOut);		}    	    }//    private void sendEmptyBundlesWithSource(SourceIpPortBean bean){//    	//    }//    private void sendEmptyBundlesWithoutSource(){//    	//    }    public void startProxy(){    	Debug.writeActivity("Starting gateway.",this);    	for (OSCPortIn oscPortIn : oscPortsIn){    		oscPortIn.startListening();    	}    	resetTuioClientMessages();    }        public void stopProxy(){    	Debug.writeActivity("Stopping gateway.",this);    	if(oscPortsIn != null){	    	for (OSCPortIn oscPortIn : oscPortsIn){	    		oscPortIn.stopListening();	    	}    	}	    resetTuioClientMessages();    }    	public void setInboundPorts(int[] inboundPorts){		oscPortsIn = new Vector<OSCPortIn>(); 		try {			for(int i=0; i < inboundPorts.length; i++){				OSCPortIn portIn = new OSCPortIn(inboundPorts[i]);				portIn.addListener("", this);				oscPortsIn.add(portIn);			}		 } catch (SocketException e) {			Debug.writeException("Socket problems. Could not connect to inbound ports: ", this, e);		 }	}	public int[] getInboundPorts(){		int[] portsIn = new int[oscPortsIn.size()];				int i = 0;		for(OSCPortIn portIn:oscPortsIn){			portsIn[i] = portIn.getPort(); 			i = i+1;		}		return portsIn;	}	public void setOutboundConnection(InetAddress outboundIp, int outboundPort){		try{			this.oscPortOut = new OSCPortOut(outboundIp, outboundPort);		}catch (SocketException e) {			Debug.writeActivity(e.getMessage(),this);		}	}		public void acceptMessage(Date time, OSCMessage message) {}	public void acceptBundle(Date time, OSCBundle bundle){		try {			for(OSCListener listener:listeners){				listener.acceptBundle(time, bundle);			}//			Debug.writeActivity("Bundle before multiplexing: "+bundle, this);			bundle = ThrongMultiplexer.getInstance().multiplexTuioBundle(bundle);			bundle = ThrongCropper.getInstance().globalizeTuioBundle(bundle, bundle.getPortIn());//			Debug.writeActivity("Bundle after multiplexing: "+bundle, this);						checkSource(bundle);			    		oscPortOut.send(bundle);		} catch (Exception e) {			Debug.writeException("Exception while treating or sending OSCBundle: ",this, e);		}	}	public void checkSource(OSCBundle bundle){		String source = null;		for(OSCPacket packt:bundle.getPackets()){			OSCMessage message = (OSCMessage)packt;			if(message.getArguments()[0].equals("source")){				source = (String)message.getArguments()[1]; 			}		}					addConnectedSource(source, bundle.getIpAddress(), bundle.getPortOut());	}		public void addConnectedSource(String source, InetAddress ipAddress, int port){		connectedSources.put(generateConnectedSourceKey(ipAddress, port), new SourceIpPortBean(ipAddress, port, source));	}		public void resetConnectedSources(){		connectedSources.clear();	}		public void addListener(OSCListener listener) {		listeners.add(listener);	}	public void removeListener(OSCListener listener) {		listeners.remove(listener);	}		private String generateConnectedSourceKey(InetAddress ipAddress, int port){		return ipAddress.toString()+":"+port;	}	public void addTerminator(IThrongProxyTerminator terminator){		if(!terminators.contains(terminator)){			terminators.add(terminator);		}	}	public void removeTerminator(IThrongProxyTerminator terminator){		if(terminators.contains(terminator)){			terminators.remove(terminator);		}	}}